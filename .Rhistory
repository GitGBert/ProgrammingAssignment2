ls()
list.files()
file.exists("mytest.R")
file.info("mytest.R")
file.rename("mytest.R", "mytest2.R")
file.copy("mytest2.R", "mytest3.R")
file.path("mytest3.R")
file.path (folder1, folder2)
next()
swirl()
next()
file.path(ANNA)
bye()
"file.path
2
2
2
2
(2)
)
?file.path
file.path("ANNA")
swirl()
file.path("ANNA")
file.path("folder1", "folder2")
?dir.create
dir.create("testdir2")
dir.create(file.path('testdir2', 'testdir3'), recursive = TRUE)
getwd()
setwd <- old.dir
setwd(old.dir)
bye()
swirl()
1:20
pi:10
15:1
?`:`
seq(1,20)
seq (0,10,by=0.5)
my_seq<- seq(5,10, length=30)
lenght(my_seq)
lenght(my_seq)
length(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0,times=40)
rep(c(0,1,2), times = 10)
rep(c(0,1,2), each = 10)
bye()
q()
tot <-numeric(0)
class(tot)
getwd()
setwd (c(getwd(), as.charcter(directory)))
setwd (c(getwd(), as.character(directory)))
directory <- "specdata"
setwd (c(getwd(), as.character(directory)))
getwd()
directory
setwd (paste(getwd(), as.character(directory)))
read.csv(paste(getwd(), "/", as.character(325),".csv"))
read.csv(paste(getwd(), "/", directory, as.character(325),".csv"))
read.csv(paste(getwd(), "/", directory, "/", as.character(i),".csv"))
read.csv(paste(getwd(), "/", directory, "/", as.character(325),".csv"))
read.csv(paste(getwd(), "/", directory, "/", as.character(i),".csv", collapse = NULL))
read.csv(paste(getwd(), "/", directory, "/", as.character(325),".csv", collapse = NULL))
read.csv(paste(getwd(), "/", directory, "/", i,".csv",sep = "", collapse)
)
read.csv(paste(getwd(), "/", directory, "/", 325,".csv",sep = "", collapse))
read.csv(paste(getwd(), "/", directory, "/", i,".csv",sep = ""))
read.csv(paste(getwd(), "/", directory, "/", 325,".csv",sep = ""))
read.csv(paste(getwd(), "/", directory, "/", 1,".csv",sep = ""))
fp<-"00"
i<-1
read.csv(paste(getwd(), "/", directory, "/",fp, i,".csv",sep =""))
mean(sulfate)
data <- read.csv(paste(getwd(), "/", directory, "/",fp, i,".csv",sep =""))
class(data)
mean( data$sulfate , na.rm=TRUE )
pollutant <-sulfate
pollutant<- "sulfate"
mean( data$pollutant , na.rm=TRUE )
mean( data[ ,2] , na.rm=TRUE )
polutant <-2
mean( data[ ,3] , na.rm=TRUE )
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean("specdata", "nitrate", 70:72)
pollutantmean("specdata", "sulfate", 34)
datafile <- read.csv(paste(getwd(), "/", directory, "/",034,".csv",sep =""))
fp<-0
i<-34
datafile <- read.csv(paste(getwd(), "/", directory, "/",fp, i,".csv",sep =""))
mean( datafile[ ,pCol] , na.rm=TRUE )
pCol<-2
datafile <- read.csv(paste(getwd(), "/", directory, "/",fp, i,".csv",sep =""))
mean( datafile[ ,pCol] , na.rm=TRUE )
## this is correct
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 34)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 34)
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean("specdata", "sulfate", 34)
pollutantmean("specdata", "nitrate")
pollutantmean("specdata", "nitrate", 70:72)
source("complete.R")
source("complete.R")
complete("specdata", 1)
complete("specdata", 1)
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
source("complete.R")
complete("specdata", c(2, 4, 8, 10, 12))
complete("specdata", 1)
complete("specdata", 30:25)
complete("specdata", 3)
source("complete.R")
complete("specdata", 30:25)
source("complete.R")
complete("specdata", 30:25)
source("complete.R")
complete("specdata", 30:25)
complete("specdata", c(2, 4, 8, 10, 12))
cc <- complete("specdata", c(6, 10, 20, 34, 100, 200, 310))
print(cc$nobs)
cc <‐ complete("specdata", 54)
print(cc$nobs)
set.seed(42)
cc<- complete("specdata", 332:1)
source("complete.R")
cc<- complete("specdata", 332:1)
use<-sample(332,10)
print(cc[use,"nobs"])
source(corr)
source("corr.R")
corr(specdata,100)
source("corr.R")
corr(specdata,100)
source("corr.R")
corr(specdata,100)
corr("specdata", 100)
?cor
source("corr.R")
source("complete.R")
complete("specdata")
cr <- corr("specdata", 150)
source('~/corr.R')
cr <- corr("specdata", 150)
dim(ok)
cr <- corr("specdata", 150)
source('~/corr.R')
cr <- corr("specdata", 150)
source('~/corr.R')
cr <- corr("specdata", 150)
head(cr)
source('~/corr.R')
cr <- corr("specdata", 150)
head(cr)
source('~/corr.R')
cr <- corr("specdata", 150)
source('~/corr.R')
cr <- corr("specdata", 150)
source('~/corr.R')
cr <- corr("specdata", 150)
source('~/corr.R')
cr <- corr("specdata", 150)
head(cr)
options(digits = 4)
head(cr)
summary(cr)
cr <- corr("specdata", 400)
head(cr)
source('~/corr.R')
summary(cr)
cr <- corr("specdata", 5000)
summary(cr)
length(cr)
cr <- corr("specdata")
summary(cr)
length(cr)
cr <‐ sort(cr)
set.seed(868)
out <‐ round(cr[sample(length(cr), 5)], 4)
print(out)
cr <- corr("specdata",129)
cr <‐ sort(cr)
n<-length(cr)
set.seed(197)
out <‐ c(n, round(cr[sample(n, 5)], 4))
print(out)
cr <‐ corr("specdata", 2000)
n<-length(cr)
cr <‐ corr("specdata", 1000)
cr <‐ sort(cr)
print(c(n, round(cr, 4)))
setwd("~/GitL/ProgrammingAssignment2")
ls
ls()
Q
ls
undebug(ls)
ls
dir
rm(list=ls())
ls()
untrace(ls)
ls
dim
dir()
a<-matrix (c(1,2,3,0,1,5,5,6,0), 3,3)
a
a<-matrix (c(1,0,5,2,1,6,3,5,0), 3,3)
a
solve(a)
a
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinvert <- function(invert) m <<- invert
getinvert <- function() m
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
makeCacheMatrix(a)
a
set(a)
geet(a)
debug()
ls()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvert()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinvert(m)
m
}
cacheSolve(a)
class(a)
ls(environment(makeCacheMatrix))
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinvert <- function(invert) m <<- invert
getinvert <- function() m
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
## The following function calculates the inverse of the special "matrix" created with
## the above function. However, it first checks to see if the inverse matrix has already been
## calculated. If so, it gets the inverse matrix from the cache and skips the computation.
## Otherwise, it calculates the inverse matrix of the data and sets the value of the inverse
## matrix in the cache via the setinvert function.
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvert()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinvert(m)
m
} ## the cacheSolve function is defined within the scoping of the makeCacheMatrix function
}
makeCacheMatrix(a)
a
ls(environment(makeCacheMatrix))
get a
get(a)
cacheSolve(a)
ls(environment(cacheSolve))
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinvert <- function(solve) m <<- solve
getinvert <- function() m
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
## The following function calculates the inverse of the special "matrix" created with
## the above function. However, it first checks to see if the inverse matrix has already been
## calculated. If so, it gets the inverse matrix from the cache and skips the computation.
## Otherwise, it calculates the inverse matrix of the data and sets the value of the inverse
## matrix in the cache via the setinvert function.
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvert()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinvert(m)
m
} ## the cacheSolve function is defined within the scoping of the makeCacheMatrix function
}
a
makeCacheMatrix(a)
a
get()
get(a)
cacheSolve(a)
set(a)
ls()
makeCacheMatrix$get(a)
makeCacheMatrix$get()
makeCacheMatrix$get(x)
## Cache of Matrix Inversion
## Matrix inversion is usually a costly computation and there may
## be some benefit to caching the inverse of a matrix rather than
## compute it repeatedly. This assignment is to write a pair of
## functions that cache the inverse of a matrix.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinvert <- function(solve) m <<- solve
getinvert <- function() m
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
## The following function calculates the inverse of the special "matrix" created with
## the above function. However, it first checks to see if the inverse matrix has already been
## calculated. If so, it gets the inverse matrix from the cache and skips the computation.
## Otherwise, it calculates the inverse matrix of the data and sets the value of the inverse
## matrix in the cache via the setinvert function.
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvert()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinvert(m)
m
} ## the cacheSolve function is defined within the scoping of the makeCacheMatrix function
ls()
makeCacheMatrix()
ls()
makeCacheMatrix(a)
makeCacheMatrix$get(a)
makeCacheMatrix$get()
cacheSolve(a)
source('~/GitL/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(a)
source('~/GitL/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(a)
ls()
cacheSolve(a)
source('~/GitL/ProgrammingAssignment2/cachematrix.R')
makeCacheMatrix(a)
source('~/GitL/ProgrammingAssignment2/cachematrix.R')
ls()
rm(list=ls())
ls()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
ls()
makeVector(c(9,8,7,6,5,4,3,2,1))
ls()
x$get
myVector <-makeVector(c(9,8,7,6,5,4,3,2,1))
myVector
myVector$get()
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(myVector)
rm(list(ls()))
ls()
ls()
## Cache of Matrix Inversion
## Matrix inversion is usually a costly computation and there may
## be some benefit to caching the inverse of a matrix rather than
## compute it repeatedly. This assignment is to write a pair of
## functions that cache the inverse of a matrix.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinvert <- function(solve) m <<- solve
getinvert <- function() m
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
a<- makeCacheMatrix(c(1,0,5,2,1,6,3,5,0), 3,3)
a
a<- makeCacheMatrix(c(1,0,5,2,1,6,3,5,0))
a
print(a)
a$get()
ls()
> a<-matrix (c(1,0,5,2,1,6,3,5,0), 3,3)
a<-matrix (c(1,0,5,2,1,6,3,5,0), 3,3)
a
aMatrix <- makeCacheMatrix(a)
## Cache of Matrix Inversion
## Matrix inversion is usually a costly computation and there may
## be some benefit to caching the inverse of a matrix rather than
## compute it repeatedly. This assignment is to write a pair of
## functions that cache the inverse of a matrix.
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinvert <- function(solve) m <<- solve
getinvert <- function() m
list(set = set, get = get, setinvert = setinvert, getinvert = getinvert)
}
aMatrix <- makeCacheMatrix(a)
aMatrix
aMatrix$get()
## The following function calculates the inverse of the special "matrix" created with
## the above function. However, it first checks to see if the inverse matrix has already been
## calculated. If so, it gets the inverse matrix from the cache and skips the computation.
## Otherwise, it calculates the inverse matrix of the data and sets the value of the inverse
## matrix in the cache via the setinvert function.
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinvert()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinvert(m)
m
} ## the cacheSolve function is defined within the scoping of the makeCacheMatrix function
cacheSolve(aMatrix)
source('~/GitL/ProgrammingAssignment2/cachematrix.R')
